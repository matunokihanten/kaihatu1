<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 2D Pattern in 3D</title>
    <style>
        body {
            margin: 0;
            overflow: hidden; /* スクロールバーを非表示にする */
            background-color: #f0f0f0; /* 背景色 */
        }
        canvas {
            display: block; /* canvas要素の余白をなくす */
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <script>
        // === Three.js シーンのセットアップ ===
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize( window.innerWidth, window.innerHeight );
        document.body.appendChild( renderer.domElement );

        // === 光源の追加 (テクスチャなので環境光だけでも見えますが、立体感のために追加) ===
        const ambientLight = new THREE.AmbientLight( 0xffffff, 0.8 ); // 全体を明るくする環境光
        scene.add( ambientLight );

        const directionalLight = new THREE.DirectionalLight( 0xffffff, 0.5 ); // 方向性のある光
        directionalLight.position.set( 1, 1, 1 ).normalize();
        scene.add( directionalLight );

        camera.position.z = 2; // カメラを少し手前に引く

        // === 画像をテクスチャとしてロードし、オブジェクトに適用 ===
        const textureLoader = new THREE.TextureLoader();
        let texturedObject; // ロードしたテクスチャを適用したオブジェクトを保持する変数

        textureLoader.load(
            'image.png', // ★ここにご提示いただいた画像のファイル名を指定★
            function ( texture ) {
                // 画像をテクスチャとして貼り付ける平面ジオメトリを作成
                // 画像のアスペクト比に合わせて平面のサイズを調整すると良いでしょう
                const aspectRatio = texture.image.width / texture.image.height;
                const planeGeometry = new THREE.PlaneGeometry( 2 * aspectRatio, 2 ); // 幅2 * アスペクト比, 高さ2

                // テクスチャを適用するマテリアル
                const material = new THREE.MeshBasicMaterial( { map: texture, side: THREE.DoubleSide } ); // 両面表示
                
                texturedObject = new THREE.Mesh( planeGeometry, material );
                scene.add( texturedObject );
                console.log('画像テクスチャがロードされ、オブジェクトが作成されました！');
            },
            // 読み込みの進捗状況
            function ( xhr ) {
                console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
            },
            // エラーハンドリング
            function ( error ) {
                console.error( '画像の読み込み中にエラーが発生しました', error );
            }
        );

        // === タッチ操作のための変数 ===
        let isDragging = false;
        let previousTouchX = null;
        let previousTouchY = null;
        let rotationSpeedFactor = 0.005; // 回転の感度を調整

        // === イベントリスナー (タッチ操作) ===
        renderer.domElement.addEventListener('touchstart', (event) => {
            event.preventDefault(); // デフォルトのスクロールやズームを防止
            isDragging = true;
            if (event.touches.length > 0) {
                previousTouchX = event.touches[0].clientX;
                previousTouchY = event.touches[0].clientY;
            }
        }, { passive: false });

        renderer.domElement.addEventListener('touchmove', (event) => {
            if (!isDragging || !texturedObject) return; // オブジェクトがロードされていない場合は何もしない
            event.preventDefault();

            if (event.touches.length > 0 && previousTouchX !== null && previousTouchY !== null) {
                const currentTouchX = event.touches[0].clientX;
                const currentTouchY = event.touches[0].clientY;

                const deltaX = currentTouchX - previousTouchX;
                const deltaY = currentTouchY - previousTouchY;

                // ロードしたオブジェクトの回転を適用
                texturedObject.rotation.y += deltaX * rotationSpeedFactor;
                texturedObject.rotation.x += deltaY * rotationSpeedFactor;

                previousTouchX = currentTouchX;
                previousTouchY = currentTouchY;
            }
        }, { passive: false });

        renderer.domElement.addEventListener('touchend', () => {
            isDragging = false;
            previousTouchX = null;
            previousTouchY = null;
        });

        renderer.domElement.addEventListener('touchcancel', () => {
            isDragging = false;
            previousTouchX = null;
            previousTouchY = null;
        });

        // === アニメーションループ ===
        function animate() {
            requestAnimationFrame( animate );
            renderer.render( scene, camera );
        }
        animate();

        // === ウィンドウリサイズ時の処理 ===
        window.addEventListener( 'resize', () => {
            const newWidth = window.innerWidth;
            const newHeight = window.innerHeight;
            camera.aspect = newWidth / newHeight;
            camera.updateProjectionMatrix();
            renderer.setSize( newWidth, newHeight );
        }, false );
    </script>
</body>
</html>
