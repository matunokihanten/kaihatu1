<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Adjustable Bumpy Sphere</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; font-family: sans-serif; color: #eee; }
        canvas { display: block; }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            max-width: 280px; /* 少し幅を広げる */
            z-index: 10;
        }
        #controls label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #controls input[type="range"] {
            width: 100%;
            margin-bottom: 10px;
            -webkit-appearance: none;
            height: 5px;
            background: #555;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
        }
        #controls input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
        }
        #controls input[type="range"]::-moz-range-thumb {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
        }
        #controls button, #controls select {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
            width: 100%;
            margin-top: 5px; /* マージンを少し調整 */
        }
        #controls button:hover, #controls select:hover {
            background-color: #0056b3;
        }
        #controls select {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: url('data:image/svg+xml;utf8,<svg fill="white" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M7 10l5 5 5-5z"/><path d="M0 0h24v24H0z" fill="none"/></svg>');
            background-repeat: no-repeat;
            background-position: right 8px top 50%;
            padding-right: 30px;
        }
    </style>
</head>
<body>
    <div id="controls">
        <label for="speed-slider">回転スピード: <span id="speed-value">0.005</span></label>
        <input type="range" id="speed-slider" min="0.001" max="0.05" step="0.0005" value="0.005">

        <label for="scale-slider">球体サイズ: <span id="scale-value">1.0</span></label>
        <input type="range" id="scale-slider" min="0.5" max="2.0" step="0.05" value="1.0">

        <label for="complexity-slider">複雑度: <span id="complexity-value">32</span></label>
        <input type="range" id="complexity-slider" min="8" max="64" step="8" value="32">

        <label for="displacement-slider">凹凸の強さ: <span id="displacement-value">0.10</span></label>
        <input type="range" id="displacement-slider" min="0.0" max="0.3" step="0.01" value="0.1">

        <label for="friction-slider">慣性: <span id="friction-value">0.95</span></label>
        <input type="range" id="friction-slider" min="0.85" max="0.99" step="0.01" value="0.95">

        <label for="texture-select">テクスチャ:</label>
        <select id="texture-select">
            <option value="random_blocks">ランダムブロック</option>
            <option value="noise_pattern">ノイズパターン</option>
            <option value="gradient">グラデーション</option>
        </select>

        <button id="randomize-button">ランダムに変化</button>
    </div>

    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.165.0/build/three.module.js';

        let scene, camera, renderer, sphere;
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let rotationSpeedX = 0;
        let rotationSpeedY = 0;
        let autoRotateSpeed = 0.005; // 自動回転の基本速度
        let autoRotateStartTime = Date.now();
        const AUTO_ROTATE_DELAY = 5000; // 5秒後に自動回転開始

        let initialPinchDistance = 0;
        let initialSphereScale = 1; // 現在の球体のスケール (ピンチ用)

        // ズームイン・アウトの限界
        const MIN_CAMERA_Z = 1.2;
        const MAX_CAMERA_Z = 5.0; // カメラのZ座標でズームを制御

        // UI要素
        const speedSlider = document.getElementById('speed-slider');
        const speedValueSpan = document.getElementById('speed-value');
        const scaleSlider = document.getElementById('scale-slider');
        const scaleValueSpan = document.getElementById('scale-value');
        const complexitySlider = document.getElementById('complexity-slider');
        const complexityValueSpan = document.getElementById('complexity-value');
        const displacementSlider = document.getElementById('displacement-slider'); // 新しいスライダー
        const displacementValueSpan = document.getElementById('displacement-value'); // 新しいスライダー
        const frictionSlider = document.getElementById('friction-slider'); // 新しいスライダー
        const frictionValueSpan = document.getElementById('friction-value'); // 新しいスライダー
        const textureSelect = document.getElementById('texture-select'); // 新しいセレクトボックス
        const randomizeButton = document.getElementById('randomize-button');

        function init() {
            // シーンの作成
            scene = new THREE.Scene();

            // カメラの作成
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = parseFloat(scaleSlider.value) + 1.0; // 球体の初期サイズに合わせてカメラ位置を調整
            camera.position.z = Math.max(MIN_CAMERA_Z, Math.min(MAX_CAMERA_Z, camera.position.z)); // 限界を適用

            // レンダラーの作成
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // 球体の作成（初期値で生成）
            createBumpySphere(
                parseFloat(scaleSlider.value),
                parseInt(complexitySlider.value),
                parseFloat(displacementSlider.value),
                textureSelect.value
            );

            // ライトの追加
            const ambientLight = new THREE.AmbientLight(0x404040, 2);
            scene.add(ambientLight);

            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.7);
            directionalLight1.position.set(1, 1, 1).normalize();
            scene.add(directionalLight1);

            const directionalLight2 = new THREE.DirectionalLight(0xaaaaaa, 0.3);
            directionalLight2.position.set(-1, -1, -1).normalize();
            scene.add(directionalLight2);

            // イベントリスナー
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
            renderer.domElement.addEventListener('touchmove', onTouchMove, { passive: false });
            renderer.domElement.addEventListener('touchend', onTouchEnd);
            window.addEventListener('resize', onWindowResize);

            // UIスライダーのイベントリスナー
            speedSlider.addEventListener('input', (event) => {
                autoRotateSpeed = parseFloat(event.target.value);
                speedValueSpan.textContent = autoRotateSpeed.toFixed(3);
            });

            scaleSlider.addEventListener('input', (event) => {
                const newScale = parseFloat(event.target.value);
                sphere.scale.set(newScale, newScale, newScale);
                scaleValueSpan.textContent = newScale.toFixed(1);

                // 球体サイズに合わせてカメラZ位置を調整（ズーム）
                camera.position.z = newScale + 1.0;
                camera.position.z = Math.max(MIN_CAMERA_Z, Math.min(MAX_CAMERA_Z, camera.position.z));
            });

            complexitySlider.addEventListener('input', (event) => {
                const newComplexity = parseInt(event.target.value);
                createBumpySphere(
                    parseFloat(scaleSlider.value),
                    newComplexity,
                    parseFloat(displacementSlider.value),
                    textureSelect.value
                );
                complexityValueSpan.textContent = newComplexity;
            });

            displacementSlider.addEventListener('input', (event) => {
                const newDisplacement = parseFloat(event.target.value);
                createBumpySphere(
                    parseFloat(scaleSlider.value),
                    parseInt(complexitySlider.value),
                    newDisplacement, // 新しい変位を渡す
                    textureSelect.value
                );
                displacementValueSpan.textContent = newDisplacement.toFixed(2);
            });

            frictionSlider.addEventListener('input', (event) => {
                frictionValueSpan.textContent = parseFloat(event.target.value).toFixed(2);
            });

            textureSelect.addEventListener('change', (event) => {
                createBumpySphere(
                    parseFloat(scaleSlider.value),
                    parseInt(complexitySlider.value),
                    parseFloat(displacementSlider.value),
                    event.target.value // 選択されたテクスチャタイプを渡す
                );
            });

            randomizeButton.addEventListener('click', () => {
                // スピードをランダムに
                const randomSpeed = getRandomFloat(parseFloat(speedSlider.min), parseFloat(speedSlider.max));
                speedSlider.value = randomSpeed;
                speedValueSpan.textContent = randomSpeed.toFixed(3);
                autoRotateSpeed = randomSpeed;

                // スケールをランダムに
                const randomScale = getRandomFloat(parseFloat(scaleSlider.min), parseFloat(scaleSlider.max));
                scaleSlider.value = randomScale;
                scaleValueSpan.textContent = randomScale.toFixed(1);
                sphere.scale.set(randomScale, randomScale, randomScale);
                camera.position.z = randomScale + 1.0;
                camera.position.z = Math.max(MIN_CAMERA_Z, Math.min(MAX_CAMERA_Z, camera.position.z));


                // 複雑度をランダムに
                const randomComplexity = getRandomInt(8, 64); // 8の倍数
                complexitySlider.value = randomComplexity;
                complexityValueSpan.textContent = randomComplexity;

                // 凹凸の強さをランダムに
                const randomDisplacement = getRandomFloat(parseFloat(displacementSlider.min), parseFloat(displacementSlider.max));
                displacementSlider.value = randomDisplacement;
                displacementValueSpan.textContent = randomDisplacement.toFixed(2);

                // 慣性をランダムに
                const randomFriction = getRandomFloat(parseFloat(frictionSlider.min), parseFloat(frictionSlider.max));
                frictionSlider.value = randomFriction;
                frictionValueSpan.textContent = randomFriction.toFixed(2);

                // テクスチャをランダムに
                const textureOptions = Array.from(textureSelect.options).map(opt => opt.value);
                const randomTexture = textureOptions[Math.floor(Math.random() * textureOptions.length)];
                textureSelect.value = randomTexture;

                createBumpySphere(randomScale, randomComplexity, randomDisplacement, randomTexture);
            });
        }

        // ヘルパー関数: ランダムな浮動小数点数を生成
        function getRandomFloat(min, max) {
            return Math.random() * (max - min) + min;
        }

        // ヘルパー関数: 指定されたステップでランダムな整数を生成 (複雑度用)
        function getRandomInt(min, max, step = 8) {
            return Math.floor(Math.random() * ((max - min) / step + 1)) * step + min;
        }

        // 凹凸のある球体を生成する関数（引数を追加）
        function createBumpySphere(scale, complexity, displacementStrength, textureType) {
            if (sphere) {
                scene.remove(sphere);
                sphere.geometry.dispose();
                sphere.material.dispose();
            }

            let texture;
            switch (textureType) {
                case 'random_blocks':
                    texture = createRandomBlocksTexture();
                    break;
                case 'noise_pattern':
                    texture = createNoisePatternTexture();
                    break;
                case 'gradient':
                    texture = createGradientTexture();
                    break;
                default:
                    texture = createRandomBlocksTexture();
            }

            const geometry = new THREE.SphereGeometry(1, complexity, complexity);

            const positionAttribute = geometry.getAttribute('position');
            const tempVector = new THREE.Vector3();
            for (let i = 0; i < positionAttribute.count; i++) {
                tempVector.fromBufferAttribute(positionAttribute, i);
                const normal = tempVector.clone().normalize();
                // 凹凸の強さスライダーの値を使用
                const displacement = (Math.random() - 0.5) * 2 * displacementStrength; // -displacementStrength から +displacementStrength の範囲
                tempVector.add(normal.multiplyScalar(displacement));
                positionAttribute.setXYZ(i, tempVector.x, tempVector.y, tempVector.z);
            }
            geometry.computeVertexNormals(); // 法線を再計算

            const material = new THREE.MeshStandardMaterial({
                map: texture,
                roughness: 0.7,
                metalness: 0.2
            });

            sphere = new THREE.Mesh(geometry, material);
            sphere.scale.set(scale, scale, scale); // 初期スケールを設定
            scene.add(sphere);
        }

        // --- テクスチャ生成関数群 ---
        function createRandomBlocksTexture() {
            const textureSize = 64;
            const cellSize = 8;
            const canvas = document.createElement('canvas');
            canvas.width = textureSize;
            canvas.height = textureSize;
            const context = canvas.getContext('2d');

            for (let y = 0; y < textureSize; y += cellSize) {
                for (let x = 0; x < textureSize; x += cellSize) {
                    const r = Math.floor(Math.random() * 255);
                    const g = Math.floor(Math.random() * 255);
                    const b = Math.floor(Math.random() * 255);
                    context.fillStyle = `rgb(${r},${g},${b})`;
                    context.fillRect(x, y, cellSize, cellSize);
                }
            }
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.LinearMipmapLinearFilter;
            return texture;
        }

        function createNoisePatternTexture() {
            const textureSize = 64;
            const canvas = document.createElement('canvas');
            canvas.width = textureSize;
            canvas.height = textureSize;
            const context = canvas.getContext('2d');
            const imageData = context.createImageData(textureSize, textureSize);

            for (let i = 0; i < textureSize * textureSize; i++) {
                const value = Math.floor(Math.random() * 255);
                imageData.data[i * 4] = value;
                imageData.data[i * 4 + 1] = value;
                imageData.data[i * 4 + 2] = value;
                imageData.data[i * 4 + 3] = 255; // Alpha
            }
            context.putImageData(imageData, 0, 0);
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            texture.magFilter = THREE.LinearFilter; // ノイズは滑らかに
            texture.minFilter = THREE.LinearMipmapLinearFilter;
            return texture;
        }

        function createGradientTexture() {
            const textureSize = 64;
            const canvas = document.createElement('canvas');
            canvas.width = textureSize;
            canvas.height = textureSize;
            const context = canvas.getContext('2d');

            const gradient = context.createLinearGradient(0, 0, textureSize, textureSize);
            gradient.addColorStop(0, 'purple');
            gradient.addColorStop(0.5, 'cyan');
            gradient.addColorStop(1, 'yellow');
            context.fillStyle = gradient;
            context.fillRect(0, 0, textureSize, textureSize);

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            texture.magFilter = THREE.LinearFilter;
            texture.minFilter = THREE.LinearMipmapLinearFilter;
            return texture;
        }
        // --- テクスチャ生成関数群 終了 ---


        function onMouseDown(event) {
            isDragging = true;
            previousMousePosition = {
                x: event.clientX,
                y: event.clientY
            };
        }

        function onMouseMove(event) {
            if (!isDragging) return;

            const deltaX = event.clientX - previousMousePosition.x;
            const deltaY = event.clientY - previousMousePosition.y;

            rotationSpeedY = deltaX * 0.005;
            rotationSpeedX = deltaY * 0.005;

            previousMousePosition = {
                x: event.clientX,
                y: event.clientY
            };
        }

        function onMouseUp() {
            isDragging = false;
        }

        function onTouchStart(event) {
            event.preventDefault();

            if (event.touches.length === 1) {
                isDragging = true;
                previousMousePosition = {
                    x: event.touches[0].clientX,
                    y: event.touches[0].clientY
                };
            } else if (event.touches.length === 2) {
                isDragging = false; // ピンチ中はドラッグを無効化
                initialPinchDistance = getPinchDistance(event.touches);
                initialSphereScale = sphere.scale.x; // 現在の球体のスケールを保存
            }
        }

        function onTouchMove(event) {
            event.preventDefault();

            if (event.touches.length === 1 && isDragging) {
                const deltaX = event.touches[0].clientX - previousMousePosition.x;
                const deltaY = event.touches[0].clientY - previousMousePosition.y;

                rotationSpeedY = deltaX * 0.005;
                rotationSpeedX = deltaY * 0.005;

                previousMousePosition = {
                    x: event.touches[0].clientX,
                    y: event.touches[0].clientY
                };
            } else if (event.touches.length === 2) {
                const currentPinchDistance = getPinchDistance(event.touches);
                const scaleFactor = currentPinchDistance / initialPinchDistance;
                let newScale = initialSphereScale * scaleFactor;

                // ズームイン・アウトの限界を適用（球体サイズで制御）
                newScale = Math.max(parseFloat(scaleSlider.min), Math.min(parseFloat(scaleSlider.max), newScale));

                sphere.scale.set(newScale, newScale, newScale);
                scaleSlider.value = newScale; // スライダーも同期
                scaleValueSpan.textContent = newScale.toFixed(1);

                // 球体サイズに合わせてカメラZ位置を調整（ズーム）
                camera.position.z = newScale + 1.0; // 1.0はオフセット
                camera.position.z = Math.max(MIN_CAMERA_Z, Math.min(MAX_CAMERA_Z, camera.position.z));
            }
        }

        function onTouchEnd() {
            isDragging = false;
        }

        function getPinchDistance(touches) {
         