<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>High-Contrast Glossy Neon Trainer</title>
    <style>
        :root {
            --bg-color: #050510;
            --glow-color: #00f2ff;
            --accent-color: #ff0055; /* アクセントカラーをより鮮やかに */
        }
        body {
            margin: 0; padding: 0;
            background-color: var(--bg-color);
            color: #fff; font-family: 'Helvetica Neue', Arial, sans-serif;
            overflow: hidden; touch-action: none;
        }

        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: space-between; align-items: center;
            padding: 30px 0; box-sizing: border-box;
            z-index: 100; pointer-events: none;
        }

        #header, #footer { pointer-events: auto; text-align: center; }

        h1 {
            font-size: 1.8rem; letter-spacing: 4px; margin: 0;
            background: linear-gradient(90deg, var(--glow-color), #fff, var(--accent-color));
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(0, 242, 255, 0.8);
        }

        #message {
            margin-top: 10px; font-size: 1.2rem; font-weight: bold;
            color: #fff; text-shadow: 0 0 10px var(--glow-color);
            min-height: 1.5rem;
        }

        .btn-group { display: flex; gap: 20px; justify-content: center; margin-bottom: 20px; }

        .btn {
            background: rgba(0, 242, 255, 0.2);
            border: 2px solid var(--glow-color); color: #fff;
            padding: 14px 36px; font-size: 1.1rem; font-weight: bold;
            border-radius: 50px; cursor: pointer;
            text-transform: uppercase; letter-spacing: 1px;
            transition: 0.3s; pointer-events: auto;
            box-shadow: 0 0 20px rgba(0, 242, 255, 0.3);
            backdrop-filter: blur(5px);
        }
        .btn:hover { background: var(--glow-color); color: #000; box-shadow: 0 0 50px var(--glow-color); }
        .btn.poly { border-color: var(--accent-color); background: rgba(255, 0, 85, 0.2); }
        .btn.poly:hover { background: var(--accent-color); color: #000; box-shadow: 0 0 50px var(--accent-color); }

        .hidden { display: none !important; }
        canvas { position: absolute; top: 0; left: 0; z-index: 1; }
        #loading { position: fixed; top:0; left:0; width:100%; height:100%; background:#000; z-index:999; display:flex; justify-content:center; align-items:center; color:var(--glow-color); font-size:1.5rem; }
    </style>
</head>
<body>
    <div id="loading">Loading High-Quality Assets...</div>
    <div id="ui-layer">
        <div id="header">
            <h1>VIVID GLOSS</h1>
            <div id="message">準備中...</div>
        </div>
        <div id="footer">
            <div id="mode-select" class="btn-group hidden">
                <button class="btn" onclick="setMode('rect')">直方体</button>
                <button class="btn poly" onclick="setMode('sphere')">多面体</button>
            </div>
            <div id="game-controls" class="btn-group hidden">
                <button class="btn" onclick="startGame()">スタート</button>
            </div>
            <div id="result-controls" class="btn-group hidden">
                <button class="btn" onclick="resetGame()">もう一度</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/RGBELoader.js"></script>

    <script>
        let scene, camera, renderer, currentObject, envMap;
        let gameState = 'init'; 
        let targetId = null;
        let rotX = 0, rotY = 0;
        let isDragging = false, lastMouseX, lastMouseY;
        let currentMode = '';

        // サイバーパンクな環境マップ
        const hdriUrl = 'https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/neon_photostudio_1k.hdr';

        // ハッキリと違う色のリスト（12色）
        const distinctHues = [
            0,   // 赤
            30,  // オレンジ
            60,  // 黄色
            120, // 緑
            150, // 青緑
            180, // シアン
            210, // スカイブルー
            240, // 青
            270, // 紫
            300, // マゼンタ
            330, // ピンク
            90   // 黄緑
        ];

        window.addEventListener('load', init);

        function init() {
            if (typeof THREE === 'undefined') {
                document.getElementById('loading').textContent = "エラー: ライブラリの読み込みに失敗しました。リロードしてください。";
                return;
            }

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 2000);
            camera.position.z = 450;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            renderer.outputEncoding = THREE.sRGBEncoding;
            document.body.appendChild(renderer.domElement);

            new THREE.RGBELoader()
                .load(hdriUrl, function (texture) {
                    texture.mapping = THREE.EquirectangularReflectionMapping;
                    envMap = texture;
                    scene.environment = envMap; 

                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('mode-select').classList.remove('hidden');
                    document.getElementById('message').textContent = "お好きな形状を選んでください";
                    
                    const sun = new THREE.DirectionalLight(0xffffff, 1.5);
                    sun.position.set(100, 200, 300);
                    scene.add(sun);
                    const blueLight = new THREE.PointLight(0x00f2ff, 2, 800);
                    blueLight.position.set(-200, 100, 200);
                    scene.add(blueLight);
                    const purpleLight = new THREE.PointLight(0xff0055, 2, 800);
                    purpleLight.position.set(200, -100, 200);
                    scene.add(purpleLight);

                    animate();
                }, undefined, function(err) {
                    document.getElementById('loading').textContent = "環境マップの読み込みに失敗しました。リロードしてください。";
                });
        }

        // インデックスに基づいて、ハッキリ違う色を生成する関数
        function getColorForIndex(index, total) {
            const hueIndex = index % distinctHues.length;
            const hue = distinctHues[hueIndex];
            
            // 同じ色相でも、周回ごとに輝度を変えてバリエーションを出す
            // 1周目:標準(50%), 2周目:明るめ(65%), 3周目:暗め(35%)
            const cycle = Math.floor(index / distinctHues.length);
            let lightness = 50;
            if (cycle % 3 === 1) lightness = 65;
            if (cycle % 3 === 2) lightness = 35;
            
            return new THREE.Color(`hsl(${hue}, 100%, ${lightness}%)`);
        }


        // 超光沢マテリアルを作成する関数
        function createGlossyMaterial(color) {
            return new THREE.MeshPhysicalMaterial({
                color: color,
                metalness: 0.2,
                roughness: 0.05,
                clearcoat: 1.0,
                clearcoatRoughness: 0.02,
                reflectivity: 1.0,
                envMapIntensity: 1.5
            });
        }

        function setMode(mode) {
            currentMode = mode;
            if (currentObject) scene.remove(currentObject);
            currentObject = mode === 'rect' ? createRect() : createPoly();
            scene.add(currentObject);
            document.getElementById('mode-select').classList.add('hidden');
            document.getElementById('game-controls').classList.remove('hidden');
            document.getElementById('message').textContent = "準備完了！";
            gameState = 'ready';
            currentObject.scale.set(0,0,0);
            const startTime = Date.now();
            function appear() {
                const elapsed = Date.now() - startTime;
                const p = Math.min(elapsed / 1000, 1);
                const ease = p * (2-p);
                currentObject.scale.set(ease, ease, ease);
                if(p<1) requestAnimationFrame(appear);
            }
            appear();
        }

        function createRect() {
            const group = new THREE.Group();
            let id=0;
            const totalTiles = 40; // 直方体のタイル総数

            for(let f=0; f<4; f++) {
                for(let i=0; i<8; i++) {
                    const geo = new THREE.BoxGeometry(75, 75, 5);
                    const color = getColorForIndex(id, totalTiles);
                    const mat = createGlossyMaterial(color);
                    const tile = new THREE.Mesh(geo, mat);
                    tile.userData.id = id++;
                    const col = i%2; const row = Math.floor(i/2);
                    tile.position.set((col-0.5)*80, (row-1.5)*80, 85);
                    const pivot = new THREE.Group();
                    pivot.rotation.y = (Math.PI/2)*f;
                    pivot.add(tile);
                    group.add(pivot);
                }
            }
            for(let f=0; f<2; f++) {
                for(let i=0; i<4; i++) {
                    const geo = new THREE.BoxGeometry(75, 5, 75);
                    const color = getColorForIndex(id, totalTiles);
                    const mat = createGlossyMaterial(color);
                    const tile = new THREE.Mesh(geo, mat);
                    tile.userData.id = id++;
                    const col = i%2; const row = Math.floor(i/2);
                    tile.position.set((col-0.5)*80, (f===0?165:-165), (row-0.5)*80);
                    group.add(tile);
                }
            }
            return group;
        }

        function createPoly() {
            const geo = new THREE.IcosahedronGeometry(170, 1);
            const count = geo.attributes.position.count / 3;
            const materials = [];
            for(let i=0; i<count; i++) {
                geo.addGroup(i*3, 3, i);
                const color = getColorForIndex(i, count);
                materials.push(createGlossyMaterial(color));
            }
            const mesh = new THREE.Mesh(geo, materials);
            mesh.userData.isPoly = true;
            return mesh;
        }

        function startGame() {
            if (gameState !== 'ready') return;
            gameState = 'memorizing';
            document.getElementById('game-controls').classList.add('hidden');

            const max = currentMode === 'rect' ? 40 : currentObject.material.length;
            targetId = Math.floor(Math.random() * max);
            const targetMat = getMaterialById(targetId);
            const originalColor = targetMat.color.clone();
            
            document.getElementById('message').textContent = "この光るパネルを記憶して！";
            
            const startTime = Date.now();
            function pulse() {
                if(gameState !== 'memorizing') return;
                const elapsed = Date.now() - startTime;
                const intensity = (Math.sin(elapsed * 0.01) + 1) * 2 + 1;
                targetMat.emissive.set(0xffffff);
                targetMat.emissiveIntensity = intensity;
                requestAnimationFrame(pulse);
            }
            pulse();

            setTimeout(() => {
                targetMat.color.copy(originalColor);
                targetMat.emissive.set(0x000000);
                startShuffle();
            }, 3000);
        }

        function startShuffle() {
            gameState = 'shuffling';
            document.getElementById('message').textContent = "シャッフル中... 目で追って！";
            
            const extraRotX = (Math.PI/2) * Math.floor(Math.random()*4) + Math.PI * 6;
            const extraRotY = (Math.PI/2) * Math.floor(Math.random()*4) + Math.PI * 6;
            
            const startX = currentObject.rotation.x;
            const startY = currentObject.rotation.y;
            const startTime = Date.now();
            const duration = 3500;

            function doShuffle() {
                const elapsed = Date.now() - startTime;
                const p = Math.min(elapsed / duration, 1);
                const ease = p * p * (3 - 2 * p);
                currentObject.rotation.x = startX + extraRotX * ease;
                currentObject.rotation.y = startY + extraRotY * ease;

                if(p < 1) requestAnimationFrame(doShuffle);
                else {
                    gameState = 'guessing';
                    document.getElementById('message').textContent = "ターゲットはどこ？ (ドラッグで回転、クリックで決定)";
                }
            }
            doShuffle();
        }

        function handleTileClick(event) {
            if (gameState !== 'guessing') return;

            const mouse = new THREE.Vector2(
                (event.clientX / window.innerWidth) * 2 - 1,
                -(event.clientY / window.innerHeight) * 2 + 1
            );
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);

            const intersects = currentMode === 'rect' ? 
                raycaster.intersectObjects(getAllRectTiles()) : 
                raycaster.intersectObject(currentObject);

            if (intersects.length > 0) {
                const hit = intersects[0];
                const clickedId = currentMode === 'rect' ? hit.object.userData.id : hit.face.materialIndex;
                const correctMat = getMaterialById(targetId);

                if (clickedId === targetId) {
                    document.getElementById('message').innerHTML = "<span style='color:#00ffcc'>正解！お見事です！</span>";
                    correctMat.emissive.set(0x00ffcc);
                    correctMat.emissiveIntensity = 5;
                } else {
                    document.getElementById('message').innerHTML = "<span style='color:#ff3366'>残念... 正解はここでした</span>";
                    correctMat.emissive.set(0xff3366);
                    correctMat.emissiveIntensity = 3;
                }
                gameState = 'result';
                document.getElementById('result-controls').classList.remove('hidden');
            }
        }

        function getAllRectTiles() {
            const list = [];
            currentObject.traverse(obj => { if(obj.userData.id !== undefined) list.push(obj); });
            return list;
        }
        function getMaterialById(id) {
            if(currentMode === 'rect') return getAllRectTiles().find(t => t.userData.id === id).material;
            return currentObject.material[id];
        }
        function resetGame() {
            document.getElementById('result-controls').classList.add('hidden');
            document.getElementById('mode-select').classList.remove('hidden');
            document.getElementById('message').textContent = "モードを選んでください";
            if(currentObject) {
                const startTime = Date.now();
                function disappear() {
                    const elapsed = Date.now() - startTime;
                    const p = Math.min(elapsed / 500, 1);
                    const ease = 1 - p*p;
                    currentObject.scale.set(ease, ease, ease);
                    if(p<1) requestAnimationFrame(disappear);
                    else {
                        scene.remove(currentObject);
                        currentObject = null;
                    }
                }
                disappear();
            }
            gameState = 'init';
            rotX = 0; rotY = 0;
        }

        window.addEventListener('mousedown', (e) => { isDragging = true; lastMouseX = e.clientX; lastMouseY = e.clientY; });
        window.addEventListener('mousemove', (e) => {
            if(!isDragging || gameState === 'shuffling' || !currentObject) return;
            const dx = e.clientX - lastMouseX; const dy = e.clientY - lastMouseY;
            currentObject.rotation.y += dx * 0.005; currentObject.rotation.x += dy * 0.005;
            lastMouseX = e.clientX; lastMouseY = e.clientY;
        });
        window.addEventListener('mouseup', () => isDragging = false);
        window.addEventListener('touchstart', (e) => { isDragging = true; lastMouseX = e.touches[0].clientX; lastMouseY = e.touches[0].clientY; });
        window.addEventListener('touchmove', (e) => {
            if(!isDragging || gameState === 'shuffling' || !currentObject) return;
            const dx = e.touches[0].clientX - lastMouseX; const dy = e.touches[0].clientY - lastMouseY;
            currentObject.rotation.y += dx * 0.005; currentObject.rotation.x += dy * 0.005;
            lastMouseX = e.touches[0].clientX; lastMouseY = e.touches[0].clientY;
        });
        window.addEventListener('touchend', () => isDragging = false);
        window.addEventListener('click', handleTileClick);
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        function animate() {
            requestAnimationFrame(animate);
            if(currentObject && (gameState === 'ready' || gameState === 'guessing')) {
                if(!isDragging) {
                    currentObject.rotation.y += 0.002;
                    if(currentMode === 'sphere') currentObject.rotation.x += 0.001;
                }
            }
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
