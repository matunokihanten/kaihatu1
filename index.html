<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>万華鏡ブーム式アニメーション</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="kaleido"></canvas>
  <script>
    const canvas = document.getElementById("kaleido");
    canvas.width  = window.innerWidth;
    canvas.height = window.innerHeight;
    const ctx = canvas.getContext("2d");
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;

    const segments = 16;
    const stepAngle = (2 * Math.PI) / segments;

    let globalAngle = 0;
    let rotationSpeed = 0.01; // 初期速度
    const maxSpeed = 6000;    // 最大速度
    let time = 0;             // 時間管理用

    const patternCanvas = document.createElement("canvas");
    patternCanvas.width = 800;
    patternCanvas.height = 800;
    const pCtx = patternCanvas.getContext("2d");

    function createDynamicPattern(hue) {
      pCtx.clearRect(0, 0, patternCanvas.width, patternCanvas.height);

      const radialGradient = pCtx.createRadialGradient(
        patternCanvas.width / 2, patternCanvas.height / 2, 100,
        patternCanvas.width / 2, patternCanvas.height / 2, patternCanvas.width / 2
      );
      radialGradient.addColorStop(0, `hsl(${hue}, 80%, 60%)`);
      radialGradient.addColorStop(1, `hsl(${(hue + 180) % 360}, 80%, 20%)`);
      pCtx.fillStyle = radialGradient;
      pCtx.fillRect(0, 0, patternCanvas.width, patternCanvas.height);

      for (let i = 0; i < 150; i++) {
        pCtx.save();
        pCtx.translate(patternCanvas.width / 2, patternCanvas.height / 2);
        pCtx.rotate(Math.random() * 2 * Math.PI);
        const size = Math.random() * 100 + 20;
        pCtx.fillStyle = `hsla(${hue + Math.random() * 60}, 80%, 50%, 0.5)`;
        pCtx.beginPath();
        pCtx.arc(Math.random() * 200 - 100, Math.random() * 200 - 100, size, 0, Math.PI * 2);
        pCtx.fill();
        pCtx.restore();
      }
    }

    function animate() {
      time++;
      const hue = (time % 360); // 色相を時間経過で変更
      createDynamicPattern(hue);

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      ctx.save();
      ctx.translate(centerX, centerY);
      ctx.rotate(globalAngle);

      for (let i = 0; i < segments; i++) {
        ctx.save();
        ctx.rotate(i * stepAngle);
        if (i % 2 === 0) {
          ctx.scale(1, -1);
        }
        ctx.beginPath();
        const radius = Math.sqrt(centerX * centerX + centerY * centerY);
        ctx.arc(0, 0, radius, -stepAngle / 2, stepAngle / 2);
        ctx.closePath();
        ctx.clip();

        ctx.drawImage(
          patternCanvas,
          -patternCanvas.width / 2,
          -patternCanvas.height / 2
        );
        ctx.restore();
      }
      ctx.restore();

      // ブーム式でスピードを上げる（最大値 maxSpeed を制限）
      if (rotationSpeed < maxSpeed) {
        rotationSpeed *= 1.01; // 徐々に加速
      }
      globalAngle += rotationSpeed / 1000; // スピード反映

      requestAnimationFrame(animate);
    }
    animate();

    window.addEventListener("resize", () => {
      canvas.width  = window.innerWidth;
      canvas.height = window.innerHeight;
    });
  </script>
</body>
</html>
